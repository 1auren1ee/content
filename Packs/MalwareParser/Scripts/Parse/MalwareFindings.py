from abc import ABC, abstractmethod
from enum import Enum
from typing import Optional, Dict, Set

import demistomock as demisto
from CommonServerPython import ThreatIntel


class Status(Enum):
    SUSPICIOUS = 'Suspicious'
    BENIGN = 'Benign'


STATUS_TO_INT = {Status.SUSPICIOUS: 1, Status.BENIGN: 0}


class Source(Enum):
    SANDBOX = 'Sandbox'
    EDR = 'EDR'
    TODO = 'Todo'  # todo remove


class MalwareFinding(ABC):
    name: str
    question: Optional[str] = None
    status: Optional[Status] = None
    value: Optional[str] = None
    sources: Set[Source] = {}
    additional_attributes: Optional[Dict[str, str]] = None

    def __init__(self, name: str, context: dict, question: Optional[str] = None):
        self.name: name
        self.context = context
        self.question = question
        self._parse_context()

    def to_context(self) -> dict:
        context = {
            'Source': [source.value for source in self.sources],  # todo Source or Sources key?
        }
        if self.question:
            context['Question'] = self.question

        if self.status is not None:  # todo
            context['Status'] = self.status.value

        if self.additional_attributes is not None:
            context |= self.additional_attributes

        return {self.name: context}

    def _parse_single(self, key: str, value: str, status: Status, source: Source):
        if demisto.get(self.context, key) == value:
            self.status = status
            self.sources.add(source)

    @abstractmethod
    def _parse_context(self) -> None:
        """
        Determines all class attribute values (status, sources, etc.) from the context.
        Naturally, this is customized in each inheriting class.
        """
        pass
        # todo set benign

    def _parse_kill_chain(self, value: str) -> None:
        """ shortcut for parsing common kill chains fields """
        self._parse_single('csfalconx.resource.sandbox.mitre_attacks.tactic', value, Status.SUSPICIOUS, Source.SANDBOX)
        self._parse_single('incident.tacticname', value, Status.SUSPICIOUS, Source.EDR)
        self._parse_single('AttackPattern.KillChainPhases', value, Status.SUSPICIOUS, Source.EDR)


class KillChain(MalwareFinding, ABC):
    def __init__(self, name: str, question: str, context: dict, search_value: str):
        super().__init__(name=name, question=question, context=context)
        self.search_value = search_value

    def _parse_context(self) -> None:
        self._parse_kill_chain(self.search_value)


class Persistence(KillChain):
    def __init__(self, context: dict):
        super().__init__(name='EvidenceOfPersistence',
                         question='Is there evidence of Persistence?',
                         context=context,
                         search_value=ThreatIntel.KillChainPhases.PERSISTENCE)


class DefenseEvasion(KillChain):
    def __init__(self, context: dict):
        super().__init__(name='EvidenceOfDefenseEvasion',
                         question='Is there evidence of Defense Evasion?',
                         context=context,
                         search_value=ThreatIntel.KillChainPhases.DEFENSE_EVASION)


class Execution(KillChain):
    def __init__(self, context: dict):
        super().__init__(name='EvidenceOfExecution',
                         question='Is there evidence of Execution?',
                         context=context,
                         search_value=ThreatIntel.KillChainPhases.EXECUTION)


class LateralMovement(KillChain):
    def __init__(self, context: dict):
        super().__init__(name='EvidenceOfLateralMovement',
                         question='Is there evidence of Lateral Movement?',
                         context=context,
                         search_value=ThreatIntel.KillChainPhases.LATERAL_MOVEMENT)


class PrivilegeEscalation(KillChain):
    def __init__(self, context: dict):
        super().__init__(name='EvidenceOfPrivilegeEscalation',
                         question='Is there evidence of Privilege Escalation?',
                         context=context,
                         search_value=ThreatIntel.KillChainPhases.PRIVILEGE_ESCALATION)


class CommandAndControl(KillChain):
    def __init__(self, context: dict):
        super().__init__(name='EvidenceOfCommandAndControl',
                         question='Is there evidence of Command and Control?',
                         context=context,
                         search_value=ThreatIntel.KillChainPhases.COMMAND_AND_CONTROL)


class FileSignature(MalwareFinding):
    def _parse_context(self) -> None:
        self.additional_attributes = {}
        self.status = Status.SUSPICIOUS  # default

        # MSDE
        self._parse_single('MicrosoftATP.File.IsValidCertificate', 'true', Status.BENIGN, Source.TODO)  # todo True?

        if signer := demisto.get(self.context, 'MicrosoftATP.File.Signer'):
            self.additional_attributes['Signer'] = signer
            self.sources.add(Source.TODO)  # todo

        # WildFire
        if publisher := demisto.get(self.context, 'File.DigitalSignature.Publisher'):
            self.status = Status.BENIGN
            self.sources.add(Source.TODO)  # todo
            self.additional_attributes['Signer'] = publisher
            # todo what if both signer and publisher are found? return list? concatenate?
            # todo tie with specific hash?

    def __init__(self, context: dict):
        super().__init__(name='FileDigitalSignature',
                         question='Is the file digitally signed?',
                         context=context)


class Verdict(MalwareFinding):
    def _parse_context(self) -> None:
        raise NotImplemented()

    def __init__(self, context: dict):
        super().__init__(name='SandboxVerdict', context=context)
