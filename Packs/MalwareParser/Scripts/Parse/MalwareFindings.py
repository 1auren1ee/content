from abc import ABC, abstractmethod
from enum import Enum
from typing import Optional, Dict, Set, Union

import demistomock as demisto
from CommonServerPython import ThreatIntel, argToBoolean


class Status(Enum):
    SUSPICIOUS = 2
    BENIGN = 1
    UNKNOWN = 0

    def __ge__(self, other: "Status"):
        return self.value >= other.value


class Source(Enum):
    SANDBOX = 'Sandbox'
    EDR = 'EDR'


class MalwareFinding(ABC):
    name: str
    context: dict
    question: Optional[str]
    status: Optional[Status]
    value: Optional[str]
    sources: Set[Source]
    additional_attributes: Optional[Dict[str, str]]

    def __init__(self, name: str, context: dict, question: Optional[str] = None):
        """
        Represents a query to the context.
        :param name: Name of the query
        :param context: Context to search in.
        :param question: The question this query answers, as it's shown to the user.
        """
        self.name = name
        self.context = context
        self.question = question
        self.status = Status.UNKNOWN  # default
        self.value = None
        self.sources = set()
        self.additional_attributes = None

        self._parse_context()

    def to_context(self, include_hashes: bool) -> dict:
        context = {
            'Value': self.value,
        }

        if self.sources:
            # sources are not always defined, e.g. in Verdict.
            # sorting keeps results deterministic.
            context['Sources'] = sorted([source.value for source in self.sources])

        if self.question:
            context['Question'] = self.question

        if self.status:
            context['Status'] = self.status.name.title()  # e.g. Benign

        if include_hashes:
            for hash_name in ('SHA1', 'SHA256', 'MD5'):
                if hash_value := self.context.get(hash_name):
                    context[hash_name] = hash_value

        if self.additional_attributes:
            context |= self.additional_attributes

        return {self.name: context}

    def _parse_key(self, key: str, value: Union[str, bool], status: Status, source: Source):
        found = demisto.get(self.context, key)

        if isinstance(value, bool):
            try:
                found = argToBoolean(found)
            except ValueError:
                # todo check this makes sense
                return  # if a value can't be converted to bool, it is definitely not the expected bool one

        if found == value:
            self.status = status
            self.sources.add(source)

    @abstractmethod
    def _parse_context(self) -> None:
        """
        Determines all class attribute values (status, sources, etc.) from the context.
        Naturally, this is customized in each inheriting class.
        """
        raise NotImplemented(f'Missing implementation of _parse_context() for {self.name}')

    def __ge__(self, other: "MalwareFinding"):
        """ Preferring the severe status"""
        return self.status >= other.status


class KillChain(MalwareFinding, ABC):
    def __init__(self, name: str, question: str, context: dict, search_value: str):
        self.search_value = search_value
        super().__init__(name=name, question=question, context=context)  # calls self._parse_context

    def _parse_context(self) -> None:
        self._parse_key('csfalconx.resource.sandbox.mitre_attacks.tactic',
                        self.search_value, Status.SUSPICIOUS, Source.SANDBOX)
        self._parse_key('incident.tacticname', self.search_value, Status.SUSPICIOUS, Source.EDR)
        self._parse_key('AttackPattern.KillChainPhases', self.search_value, Status.SUSPICIOUS, Source.EDR)


class Persistence(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfPersistence',
            question='Is there evidence of Persistence?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.PERSISTENCE
        )


class DefenseEvasion(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfDefenseEvasion',
            question='Is there evidence of Defense Evasion?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.DEFENSE_EVASION
        )


class Execution(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfExecution',
            question='Is there evidence of Execution?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.EXECUTION
        )


class LateralMovement(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfLateralMovement',
            question='Is there evidence of Lateral Movement?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.LATERAL_MOVEMENT
        )


class PrivilegeEscalation(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfPrivilegeEscalation',
            question='Is there evidence of Privilege Escalation?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.PRIVILEGE_ESCALATION
        )


class CommandAndControl(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfCommandAndControl',
            question='Is there evidence of Command and Control?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.COMMAND_AND_CONTROL
        )


class FileSignature(MalwareFinding):
    def _parse_context(self) -> None:
        self.additional_attributes = {}
        self.status = Status.SUSPICIOUS  # default

        # MSDE
        self._parse_key('MicrosoftATP.File.IsValidCertificate', True, Status.BENIGN, Source.EDR)

        if signer := demisto.get(self.context, 'MicrosoftATP.File.Signer'):
            self.additional_attributes['Signer'] = signer
            self.sources.add(Source.EDR)

        # WildFire
        elif publisher := demisto.get(self.context, 'File.DigitalSignature.Publisher'):  # todo wildfire
            self.status = Status.BENIGN
            self.additional_attributes['Signer'] = publisher
            self.sources.add(Source.SANDBOX)

    def __init__(self, context: dict):
        super().__init__(name='FileDigitalSignature',
                         question='Is the file digitally signed?',
                         context=context)


class Verdict(MalwareFinding):
    def _parse_context(self) -> None:
        for dbot_score in self.context.get('DBotScore', []):
            if dbot_score.get('indicator') == self.hash_value:
                self.value = dbot_score.get('Score', '0')
                # todo source: parse? use name as is?
                break
        else:
            demisto.debug(f'Could not find DBotScore for {self.hash_value}')

    def __init__(self, context: dict, hash_value: str):
        super().__init__(name='SandboxVerdict', question='Sandbox Verdict', context=context)
        self.hash_value = hash_value

    def __ge__(self, other: "Verdict"):
        return int(self.value) >= int(other.value)
