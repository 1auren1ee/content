category: Vulnerability Management
commonfields:
  id: AzureRiskyUsers - Beta
  version: -1
configuration:
- display: Client ID
  name: client_id
  required: true
  type: 9
  hiddenpassword: true
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
description: Azure Risky Users provides access to all at-risk users and risk detections in the Azure AD environment.
display: Azure Risky Users - Beta
name: AzureRiskyUsers - Beta
script:
  commands:
  - deprecated: false
    description: Tests the connectivity to Azure.
    execution: false
    name: azure-risky-users-auth-test
  - deprecated: false
    description: Starts the authorization process. You then follow the instructions in the command results.
    execution: false
    name: azure-risky-users-auth-start
  - deprecated: false
    description: Completes the authorization process. Run this command after executing the azure-risky-users-auth-start command.
    execution: false
    name: azure-risky-users-auth-complete
  - deprecated: false
    description: Reruns the authentication. process.
    execution: false
    name: azure-risky-users-auth-reset
  - arguments:
    - auto: PREDEFINED
      default: false
      description: 'Sets the Risk State to retrieve. Possible values are: "atRisk", "confirmedCompromised", "remediated", or "dismissed"'
      isArray: false
      name: risk_state
      predefined:
      - atRisk
      - confirmedCompromised
      - remediated
      - dismissed
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: Limit of results to retrieve.
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      defaultValue: '1'
      description: Page number.
      isArray: false
      name: page
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: 'Sets the Risk Level to retrieve. Possible values are: "low", "medium", or "high"'
      isArray: false
      name: risk_level
      predefined:
      - low
      - medium
      - high
      required: false
      secret: false
    deprecated: false
    description: Returns a comma separated list of all risky users and their properties.
    execution: false
    name: azure-risky-users-list
    outputs:
    - contextPath: AzureRiskyUsers.RiskyUser.id
      description: Unique ID of the user at risk.
      type: String
    - contextPath: AzureRiskyUsers.RiskyUser.userDisplayName
      description: Risky user display name.
      type: String
    - contextPath: AzureRiskyUsers.RiskyUser.userPrincipalName
      description: Risky user principal name.
      type: String
    - contextPath: AzureRiskyUsers.RiskyUser.riskLevel
      description: 'Level of the detected risky user. Possible values are: low, medium, high, hidden, none, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskyUser.riskState
      description: 'State of the user''s risk. Possible values are: none, confirmedSafe, remediated, dismissed, atRisk, confirmedCompromised.'
      type: String
    - contextPath: AzureRiskyUsers.RiskyUser.riskLastUpdatedDateTime
      description: 'The date and time that the risky user was last updated. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: 2014-01-01T00:00:00Z'
      type: Date
    - contextPath: AzureRiskyUsers.RiskyUser.isDeleted
      description: Indicates whether the user is deleted.
      type: Boolean
    - contextPath: AzureRiskyUsers.RiskyUser.isProcessing
      description: Indicates whether a user's risky state is being processed by the backend.
      type: Boolean
    - contextPath: AzureRiskyUsers.RiskyUser.riskDetail
      description: 'Details of the detected risk. Possible values are: none, adminGeneratedTemporaryPassword, userPerformedSecuredPasswordChange, userPerformedSecuredPasswordReset, adminConfirmedSigninSafe, aiConfirmedSigninSafe, userPassedMFADrivenByRiskBasedPolicy, adminDismissedAllRiskForUser, adminConfirmedSigninCompromised, hidden, adminConfirmedUserCompromised, unknownFutureValue.'
      type: String
  - arguments:
    - default: false
      description: Risky user ID to retrieve.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Retrieves properties and relationships of a Risky User.
    execution: false
    name: azure-risky-user-get
    outputs:
    - contextPath: AzureRiskyUsers.RiskyUser.id
      description: Unique ID of the user at risk.
      type: String
    - contextPath: AzureRiskyUsers.RiskyUser.userDisplayName
      description: Risky user display name.
      type: String
    - contextPath: AzureRiskyUsers.RiskyUser.userPrincipalName
      description: Risky user principal name.
      type: String
    - contextPath: AzureRiskyUsers.RiskyUser.riskLevel
      description: 'Level of the detected risky user. Possible values are: low, medium, high, hidden, none, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskyUser.riskState
      description: 'State of the user''s risk. Possible values are: none, confirmedSafe, remediated, dismissed, atRisk, confirmedCompromised.'
      type: String
    - contextPath: AzureRiskyUsers.RiskyUser.riskLastUpdatedDateTime
      description: 'The date and time that the risky user was last updated. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: 2014-01-01T00:00:00Z'
      type: Date
    - contextPath: AzureRiskyUsers.RiskyUser.isDeleted
      description: Indicates whether the user is deleted.
      type: Boolean
    - contextPath: AzureRiskyUsers.RiskyUser.isProcessing
      description: Indicates whether a user's risky state is being processed by the backend.
      type: Boolean
    - contextPath: AzureRiskyUsers.RiskyUser.riskDetail
      description: 'Details of the detected risk. Possible values are: none, adminGeneratedTemporaryPassword, userPerformedSecuredPasswordChange, userPerformedSecuredPasswordReset, adminConfirmedSigninSafe, aiConfirmedSigninSafe, userPassedMFADrivenByRiskBasedPolicy, adminDismissedAllRiskForUser, adminConfirmedSigninCompromised, hidden, adminConfirmedUserCompromised, unknownFutureValue.'
      type: String
  - arguments:
    - default: false
      defaultValue: '50'
      description: Limit of results to retrieve.
      isArray: false
      name: limit
      predefined:
      - ''
      required: false
      secret: false
    - default: false
      defaultValue: '1'
      description: Page number.
      isArray: false
      name: page
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: 'Sets the Risk State to retrieve. Possible values are: "atRisk", "confirmedCompromised", "remediated", or "dismissed"'
      isArray: false
      name: risk_state
      predefined:
      - atRisk
      - confirmedCompromised
      - remediated
      - dismissed
      - confirmedSafe
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: 'Sets the Risk Level to retrieve. Possible values are: "low", "medium", or "high".'
      isArray: false
      name: risk_level
      predefined:
      - low
      - medium
      - high
      required: false
      secret: false
    deprecated: false
    description: Returns a comma separated list of the Risk Detection objects and their properties.
    execution: false
    name: azure-risky-users-risk-detections-list
    outputs:
    - contextPath: AzureRiskyUsers.RiskDetection.id
      description: Unique ID of the risk detection. Inherited from the entity.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.userId
      description: The unique user ID.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.userDisplayName
      description: The user display name.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.userPrincipalName
      description: The user principal name (UPN).
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.riskDetail
      description: 'Details of the detected risk. Possible values are: none, adminGeneratedTemporaryPassword, userPerformedSecuredPasswordChange, userPerformedSecuredPasswordReset, adminConfirmedSigninSafe, aiConfirmedSigninSafe, userPassedMFADrivenByRiskBasedPolicy, adminDismissedAllRiskForUser, adminConfirmedSigninCompromised, hidden, adminConfirmedUserCompromised, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.riskEventType
      description: 'The type of risk event detected. Possible values are: unlikelyTravel, anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures, malwareInfectedIPAddress, suspiciousIPAddress, leakedCredentials, investigationsThreatIntelligence, generic,adminConfirmedUserCompromised, mcasImpossibleTravel, mcasSuspiciousInboxManipulationRules, investigationsThreatIntelligenceSigninLinked, maliciousIPAddressValidCredentialsBlockedIP, and unknownFutureValue. If the risk detection is a premium detection, will show generic.'
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.riskLevel
      description: 'Level of the detected risk. Possible values are: low, medium, high, hidden, none, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.riskState
      description: 'The state of a detected risky user or sign-in. Possible values are: none, confirmedSafe, remediated, dismissed, atRisk, confirmedCompromised, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.ipAddress
      description: The IP address of the client where the risk occurred.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.source
      description: The source of the risk detection. For example, activeDirectory.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.detectionTimingType
      description: 'Timing of the detected risk (real-time/offline). Possible values are: notDefined, realtime, nearRealtime, offline, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.lastUpdatedDateTime
      description: 'Date and time that the risk detection was last updated. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is look like this: 2014-01-01T00:00:00Z'
      type: Date
    - contextPath: AzureRiskyUsers.RiskDetection.location
      description: Location of the sign-in.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.activity
      description: 'Indicates the activity type the detected risk is linked to. . Possible values are: signin, user, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.activityDateTime
      description: 'Date and time that the risky activity occurred. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is look like this: 2014-01-01T00:00:00Z'
      type: Date
    - contextPath: AzureRiskyUsers.RiskDetection.additionalInfo
      description: Additional information associated with the risk detection in JSON format.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.correlationId
      description: Correlation ID of the sign-in associated with the risk detection. This property is null if the risk detection is not associated with a sign-in.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.detectedDateTime
      description: 'Date and time that the risk was detected. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is look like this: 2014-01-01T00:00:00Z'
      type: Date
    - contextPath: AzureRiskyUsers.RiskDetection.requestId
      description: Request ID of the sign-in associated with the risk detection. This property is null if the risk detection is not associated with a sign-in.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.tokenIssuerType
      description: 'Indicates the type of token issuer for the detected sign-in risk. Possible values are: AzureAD, ADFederationServices, UnknownFutureValue.'
      type: String
  - arguments:
    - default: false
      description: The risk detection ID to retrieve.
      isArray: false
      name: id
      required: true
      secret: false
    deprecated: false
    description: Reads the properties and relationships of a riskDetection object.
    execution: false
    name: azure-risky-users-risk-detection-get
    outputs:
    - contextPath: AzureRiskyUsers.RiskDetection.id
      description: Unique ID of the risk detection. Inherited from the entity.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.userId
      description: The unique user ID.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.userDisplayName
      description: The user display name.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.userPrincipalName
      description: The user principal name (UPN).
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.riskDetail
      description: 'Details of the detected risk. Possible values are: none, adminGeneratedTemporaryPassword, userPerformedSecuredPasswordChange, userPerformedSecuredPasswordReset, adminConfirmedSigninSafe, aiConfirmedSigninSafe, userPassedMFADrivenByRiskBasedPolicy, adminDismissedAllRiskForUser, adminConfirmedSigninCompromised, hidden, adminConfirmedUserCompromised, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.riskEventType
      description: The type of risk event detected. The possible values are unlikelyTravel, anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures, malwareInfectedIPAddress, suspiciousIPAddress, leakedCredentials, investigationsThreatIntelligence, generic,adminConfirmedUserCompromised, mcasImpossibleTravel, mcasSuspiciousInboxManipulationRules, investigationsThreatIntelligenceSigninLinked, maliciousIPAddressValidCredentialsBlockedIP, and unknownFutureValue. If the risk detection is a premium detection, will show generic
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.riskLevel
      description: 'Level of the detected risk. Possible values are: low, medium, high, hidden, none, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.riskState
      description: 'The state of a detected risky user or sign-in. Possible values are: none, confirmedSafe, remediated, dismissed, atRisk, confirmedCompromised, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.ipAddress
      description: The IP address of the client where the risk occurred.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.source
      description: The source of the risk detection. For example, activeDirectory.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.detectionTimingType
      description: 'Timing of the detected risk (real-time/offline). Possible values are: notDefined, realtime, nearRealtime, offline, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.lastUpdatedDateTime
      description: 'Date and time that the risk detection was last updated. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is look like this: 2014-01-01T00:00:00Z'
      type: Date
    - contextPath: AzureRiskyUsers.RiskDetection.location
      description: Location of the sign-in.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.activity
      description: 'Indicates the activity type the detected risk is linked to. . Possible values are: signin, user, unknownFutureValue.'
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.activityDateTime
      description: 'Date and time that the risky activity occurred. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is look like this: 2014-01-01T00:00:00Z'
      type: Date
    - contextPath: AzureRiskyUsers.RiskDetection.additionalInfo
      description: Additional information associated with the risk detection in JSON format.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.correlationId
      description: Correlation ID of the sign-in associated with the risk detection. This property is null if the risk detection is not associated with a sign-in.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.detectedDateTime
      description: 'Date and time that the risk was detected. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is look like this: 2014-01-01T00:00:00Z'
      type: Date
    - contextPath: AzureRiskyUsers.RiskDetection.requestId
      description: Request ID of the sign-in associated with the risk detection. This property is null if the risk detection is not associated with a sign-in.
      type: String
    - contextPath: AzureRiskyUsers.RiskDetection.tokenIssuerType
      description: 'Indicates the type of token issuer for the detected sign-in risk. Possible values are: AzureAD, ADFederationServices, UnknownFutureValue.'
      type: String
  dockerimage: demisto/crypto:1.0.0.24380
  feed: false
  isfetch: false
  longRunning: false
  longRunningPort: false
  runonce: false
  script: >
    register_module_line('AzureRiskyUsers - Beta', 'start', __line__())

    # type: ignore





    import requests

    from urllib.parse import urlparse

    from urllib.parse import parse_qs

    from typing import Dict, Optional, Any



    class Client:
        """
        API Client to communicate with AzureRiskyUsers.
        """

        def __init__(self, client_id: str, verify: bool, proxy: bool):

            if '@' in client_id:  # for use in test-playbook
                client_id, refresh_token = client_id.split('@')
                integration_context = get_integration_context()
                integration_context.update(current_refresh_token=refresh_token)
                set_integration_context(integration_context)

            self.ms_client = MicrosoftClient(
                self_deployed=True,
                auth_id=client_id,
                token_retrieval_url='https://login.microsoftonline.com/organizations/oauth2/v2.0/token',
                grant_type=DEVICE_CODE,
                base_url='https://graph.microsoft.com/v1.0',
                verify=verify,
                proxy=proxy,
                scope='https://graph.microsoft.com/IdentityRiskyUser.Read.All '
                      'IdentityRiskEvent.ReadWrite.All IdentityRiskyUser.Read.All '
                      'IdentityRiskyUser.ReadWrite.All offline_access')

        def risky_users_list_request(self, risk_state: Optional[str], risk_level: Optional[str],
                                     limit: int, skip_token: str = None) -> dict:
            """
            List risky users.

            Args:
                risk_state (str): Risk State to retrieve.
                risk_level (str): Specify to get only results with the same Risk Level.
                limit (int): Limit of results to retrieve.
                skip_token (str): Skip token.

            Returns:
                response (dict): API response from AzureRiskyUsers.
            """
            params = remove_empty_elements({'$top': limit,
                                            '$skiptoken': skip_token,
                                            '$filter': build_query_filter(risk_state, risk_level)})

            return self.ms_client.http_request(method='GET',
                                               url_suffix="identityProtection/riskyUsers",
                                               params=params)

        def risky_user_get_request(self, id: str) -> dict:
            """
            Get risky user by ID.

            Args:
                id (str): Risky user ID to get.

            return:
                Response (dict): API response from AzureRiskyUsers.
            """
            return self.ms_client.http_request(method='GET',
                                               url_suffix=f'identityProtection/riskyUsers/{id}')

        def risk_detections_list_request(self, risk_state: Optional[str], risk_level: Optional[str],
                                         limit: int, skip_token: str = None) -> dict:
            """
            Get a list of the Risk Detection objects and their properties.

            Args:
                risk_state (str): Risk State to retrieve.
                risk_level (str): Specify to get only results with the same Risk Level.
                limit (int): Limit of results to retrieve.
                skip_token (int): Skip token.

            return:
                Response (dict): API response from AzureRiskyUsers.
            """
            params = remove_empty_elements({'$top': limit,
                                            '$skiptoken': skip_token,
                                            '$filter': build_query_filter(risk_state, risk_level)})

            return self.ms_client.http_request(method='GET',
                                               url_suffix="/identityProtection/riskDetections",
                                               params=params)

        def risk_detection_get_request(self, id: str) -> dict:
            """
            Read the properties and relationships of a riskDetection object.

            Args:
                id (str): ID of risk detection to retrieve.

            Return:
                Response (dict): API response from AzureRiskyUsers.
            """
            return self.ms_client.http_request(method='GET',
                                               url_suffix=f'/identityProtection/riskDetections/{id}')


    def build_query_filter(risk_state: Optional[str], risk_level: Optional[str]) -> Optional[str]:
        """
        Build query filter for API call, in order to get filtered results.
        API query syntax reference: https://docs.microsoft.com/en-us/graph/query-parameters.

        Args:
            risk_state (str): Wanted risk state for filter.
            risk_level (str): Wanted risk level for filter.

        Returns:
            str: Query filter string for API call.
        """
        if risk_state and risk_level:
            return f"riskState eq '{risk_state}' and riskLevel eq '{risk_level}'"
        elif risk_state:
            return f"riskState eq '{risk_state}'"
        elif risk_level:
            return f"riskLevel eq '{risk_level}'"
        else:
            return None


    def get_skip_token(next_link: Optional[str], outputs_prefix: str, outputs_key_field: str,
                       readable_output: str) -> Union[CommandResults, str]:
        if not next_link:
            return CommandResults(outputs_prefix=outputs_prefix,
                                  outputs_key_field=outputs_key_field,
                                  outputs=[],
                                  readable_output=readable_output,
                                  raw_response=[])
        else:
            parsed_url = urlparse(next_link)
            return parse_qs(parsed_url.query)['$skiptoken'][0]


    def risky_users_list_command(client: Client, args: Dict[str, str]) -> CommandResults:
        """
        List all risky users.
        Args:
            client (Client): Azure Risky Users API client.
            args (dict): Arguments for API call.
        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        limit = arg_to_number(args.get('limit', 50))
        page = arg_to_number(args.get('page', 1))
        risk_state = args.get('risk_state')
        risk_level = args.get('risk_level')
        skip_token = None

        if page > 1:
            offset = limit * (page - 1)

            raw_response = client.risky_users_list_request(risk_state,
                                                           risk_level,
                                                           offset)
            next_link = raw_response.get('@odata.nextLink')
            skip_token = get_skip_token(next_link=next_link,
                                        outputs_prefix='AzureRiskyUsers.RiskyUser',
                                        outputs_key_field='id',
                                        readable_output=f'Risky Users List\nCurrent page size: {limit}\n'
                                                        f'Showing page {page} out others that may exist')
            if type(skip_token) != str:
                return skip_token

        raw_response = client.risky_users_list_request(risk_state,
                                                       risk_level,
                                                       limit,
                                                       skip_token)

        table_headers = ['id', 'userDisplayName', 'userPrincipalName', 'riskLevel',
                         'riskState', 'riskDetail', 'riskLastUpdatedDateTime']

        outputs = raw_response.get('value', {})

        table_outputs = [{key: item.get(key) for key in item if key in table_headers}
                         for item in outputs]

        readable_output = tableToMarkdown(name=f'Risky Users List\n'
                                               f'Current page size: {args["limit"]}\n'
                                               f'Showing page {args["page"]} out others that may exist',
                                          t=table_outputs,
                                          headers=table_headers,
                                          removeNull=True,
                                          headerTransform=pascalToSpace)

        return CommandResults(outputs_prefix='AzureRiskyUsers.RiskyUser',
                              outputs_key_field='id',
                              outputs=outputs,
                              readable_output=readable_output,
                              raw_response=raw_response)


    def risky_user_get_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Get a risky user by ID.

        Args:
            client (Client): Azure Risky Users API client.
            args (dict): Arguments for API call.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        raw_response = client.risky_user_get_request(args['id'])

        table_headers = ['id', 'userDisplayName', 'userPrincipalName', 'riskLevel',
                         'riskState', 'riskDetail', 'riskLastUpdatedDateTime']

        outputs = {key: raw_response.get(key) for key in raw_response if key in table_headers}

        readable_output = tableToMarkdown(name=f'Found Risky User With ID: {raw_response.get("id")}',
                                          t=outputs,
                                          headers=table_headers,
                                          removeNull=True,
                                          headerTransform=pascalToSpace)

        return CommandResults(outputs_prefix='AzureRiskyUsers.RiskyUser',
                              outputs_key_field='id',
                              outputs=raw_response,
                              readable_output=readable_output,
                              raw_response=raw_response)


    def risk_detections_list_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieve a list of the Risk-Detection objects and their properties.

        Args:
            client (Client): Azure Risky Users API client.
            args (dict): Arguments for API call.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        limit = arg_to_number(args.get('limit', 50))
        page = arg_to_number(args.get('page', 1))
        risk_state = args.get('risk_state')
        risk_level = args.get('risk_level')
        skip_token = None

        if page > 1:
            offset = limit * (page - 1)
            raw_response = client.risk_detections_list_request(risk_state,
                                                               risk_level,
                                                               offset)

            next_link = raw_response.get('@odata.nextLink')
            skip_token = get_skip_token(next_link=next_link,
                                        outputs_prefix='AzureRiskyUsers.RiskDetection',
                                        outputs_key_field='id',
                                        readable_output=f'Risk Detections List\nCurrent page size: '
                                        f'{limit}\nShowing page {page} out others that may exist')
            if type(skip_token) != str:
                return skip_token

        raw_response = client.risk_detections_list_request(risk_state,
                                                           risk_level,
                                                           limit,
                                                           skip_token)

        table_headers = ['id', 'userId', 'userDisplayName', 'userPrincipalName', 'riskDetail',
                         'riskEventType', 'riskLevel', 'riskState', 'riskDetail', 'lastUpdatedDateTime',
                         'ipAddress']

        outputs = raw_response.get('value', {})

        table_outputs = [{key: item.get(key) for key in item if key in table_headers}
                         for item in outputs]

        readable_output = tableToMarkdown(name=f'Risk Detections List\n'
                                               f'Current page size: {args["limit"]}\n'
                                               f'Showing page {args["page"]} out others that may exist',
                                          t=table_outputs,
                                          headers=table_headers,
                                          removeNull=True,
                                          headerTransform=pascalToSpace)

        return CommandResults(outputs_prefix='AzureRiskyUsers.RiskDetection',
                              outputs_key_field='id',
                              outputs=outputs,
                              readable_output=readable_output,
                              raw_response=raw_response)


    def risk_detection_get_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Read the properties and relationships of a riskDetection object.

        Args:
            client (Client): Azure Risky Users API client.
            args (dict): Arguments for API call.
        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        raw_response = client.risk_detection_get_request(args['id'])

        table_headers = ['id', 'userId', 'userDisplayName', 'userPrincipalName', 'riskDetail',
                         'riskEventType', 'riskLevel', 'riskState', 'ipAddress',
                         'detectionTimingType', 'lastUpdatedDateTime', 'location']

        outputs = {key: raw_response.get(key) for key in raw_response if key in table_headers}

        readable_output = tableToMarkdown(name=f'Found Risk Detection with ID: '
                                               f'{raw_response.get("id")}',
                                          t=outputs,
                                          headers=table_headers,
                                          removeNull=True,
                                          headerTransform=pascalToSpace)

        return CommandResults(outputs_prefix='AzureRiskyUsers.RiskDetection',
                              outputs_key_field='id',
                              outputs=raw_response,
                              readable_output=readable_output,
                              raw_response=raw_response)


    # Authentication Functions



    def start_auth(client: Client) -> CommandResults:
        result = client.ms_client.start_auth('!azure-risky-users-auth-complete')
        return CommandResults(readable_output=result)


    def complete_auth(client: Client) -> str:
        client.ms_client.get_access_token()
        return 'Authorization completed successfully.'


    def test_connection(client: Client) -> str:
        client.ms_client.get_access_token()
        return 'Success!'


    def reset_auth() -> str:
        set_integration_context({})
        return 'Authorization was reset successfully. Run **!azure-risky-users-auth-start** to start ' \
               'the authentication process.'


    def main():
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        params = demisto.params()
        args = demisto.args()
        client_id = params.get('client_id').get('identifier', '')

        verify_certificate = not params.get('insecure', False)

        proxy = params.get('proxy', False)
        command = demisto.command()
        LOG(f'Command being called is {command}')
        try:
            requests.packages.urllib3.disable_warnings()
            client = Client(
                client_id=client_id,
                verify=verify_certificate,
                proxy=proxy)

            if command == 'test-module':
                return_results('The test module is not functional, '
                               'run the azure-risky-users-auth-start command instead.')
            elif command == 'azure-risky-users-auth-reset':
                return_results(reset_auth())
            elif command == 'azure-risky-users-auth-start':
                return_results(start_auth(client))
            elif command == 'azure-risky-users-auth-complete':
                return_results(complete_auth(client))
            elif command == 'azure-risky-users-auth-test':
                return_results(test_connection(client))
            elif command == 'azure-risky-users-list':
                return_results(risky_users_list_command(client, args))
            elif command == 'azure-risky-user-get':
                return_results(risky_user_get_command(client, args))
            elif command == 'azure-risky-users-risk-detections-list':
                return_results(risk_detections_list_command(client, args))
            elif command == 'azure-risky-users-risk-detection-get':
                return_results(risk_detection_get_command(client, args))
            else:
                raise NotImplementedError(f'{command} command is not implemented.')

        except Exception as e:
            return_error(str(e))



    ### GENERATED CODE ###: from MicrosoftApiModule import *  # noqa: E402

    # This code was inserted in place of an API module.

    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)

    import traceback





    import requests

    import re

    import base64

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM

    from typing import Dict, Tuple, List, Optional



    class Scopes:
        graph = 'https://graph.microsoft.com/.default'
        security_center = 'https://api.securitycenter.windows.com/.default'
        security_center_apt_service = 'https://securitycenter.onmicrosoft.com/windowsatpservice/.default'
        management_azure = 'https://management.azure.com/.default'


    # authorization types

    OPROXY_AUTH_TYPE = 'oproxy'

    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'


    # grant types in self-deployed authorization

    CLIENT_CREDENTIALS = 'client_credentials'

    AUTHORIZATION_CODE = 'authorization_code'

    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line

    DEVICE_CODE = 'urn:ietf:params:oauth:grant-type:device_code'

    REGEX_SEARCH_URL = r'(?P<url>https?://[^\s]+)'

    SESSION_STATE = 'session_state'

    TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
        'de': 'https://login.microsoftonline.de',
        'cn': 'https://login.chinacloudapi.cn',
    }

    GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
        'de': 'https://graph.microsoft.de',
        'cn': 'https://microsoftgraph.chinacloudapi.cn'
    }

    GRAPH_BASE_ENDPOINTS = {
        'https://graph.microsoft.com': 'com',
        'https://graph.microsoft.us': 'gcc-high',
        'https://dod-graph.microsoft.us': 'dod',
        'https://graph.microsoft.de': 'de',
        'https://microsoftgraph.chinacloudapi.cn': 'cn'
    }



    class MicrosoftClient(BaseClient):
        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: Optional[str] = '',
                     token_retrieval_url: str = '{endpoint}/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = '{graph_endpoint}/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: Optional[str] = '',
                     multi_resource: bool = False,
                     resources: List[str] = None,
                     verify: bool = True,
                     self_deployed: bool = False,
                     timeout: Optional[int] = None,
                     azure_ad_endpoint: str = '{endpoint}',
                     endpoint: str = 'com',
                     certificate_thumbprint: Optional[str] = None,
                     private_key: Optional[str] = None,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]
            self.endpoint = endpoint
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id,
                                                                      endpoint=TOKEN_RETRIEVAL_ENDPOINTS[self.endpoint])
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope.format(graph_endpoint=GRAPH_ENDPOINTS[self.endpoint])
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401
                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key,
                            'RS256',
                            certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException('Unable to use certificate authentication because `msal` is missing.')
                else:
                    self.jwt = None

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(endpoint=TOKEN_RETRIEVAL_ENDPOINTS[self.endpoint])
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: Dict[str, str] = {}

        def http_request(
                self, *args, resp_type='json', headers=None,
                return_empty_response=False, scope: Optional[str] = None,
                resource: str = '', **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if 'ok_codes' not in kwargs and not self._ok_codes:
                kwargs['ok_codes'] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

            if headers:
                default_headers.update(headers)

            if self.timeout:
                kwargs['timeout'] = self.timeout

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = 'Not Found - 404 Response'
                raise NotFoundError(error_message)

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self, resource: str = '', scope: Optional[str] = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource (str): The resource identifier for which the generated token will have access to.
                scope (str): A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get('current_refresh_token', '')
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f'{scope}_access_token' if scope else 'access_token'
            valid_until_keyword = f'{scope}_valid_until' if scope else 'valid_until'

            if self.multi_resource:
                access_token = integration_context.get(resource)
            else:
                access_token = integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    for resource_str in self.resources:
                        access_token, expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(
                    refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update({
                access_token_keyword: access_token,
                valid_until_keyword: valid_until,
                'current_refresh_token': refresh_token
            })

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _oproxy_authorize(self, resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key),
                    'scope': scope,
                    'resource': resource
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self,
                                     refresh_token: str = '',
                                     scope: Optional[str] = None,
                                     integration_context: Optional[dict] = None
                                     ) -> Tuple[str, int, str]:
            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                else:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token,
                                                                                                          resource)
                        self.resource_to_access_token[resource] = access_token

                    return '', expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(
                            resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return '', expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(self, scope: Optional[str] = None,
                                                        resource: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            # Set scope.
            if self.scope or scope:
                data['scope'] = scope if scope else self.scope

            if self.resource or resource:
                data['resource'] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(
                self, refresh_token: str = '', resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=self.resource if not resource else resource,
                redirect_uri=self.redirect_uri
            )

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            if scope:
                data['scope'] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError('Malformed auth_code parameter: Please copy the auth code from the redirected uri '
                                     'without any additional info and without the "session_state" query parameter.')
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_token_device_code(
                self, refresh_token: str = '', scope: Optional[str] = None, integration_context: Optional[dict] = None
        ) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'scope': scope
            }

            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = DEVICE_CODE
                if integration_context:
                    data['code'] = integration_context.get('device_code')

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: Optional[str]) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f'{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode',
                    data={
                        'client_id': self.client_id,
                        'scope': self.scope
                    },
                    verify=self.verify
                )
                if not response.ok:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')
            set_integration_context({'device_code': response_json.get('device_code')})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get('message', '')
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search.group('url') if re_search else None
            user_code = response.get('user_code')

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})

    and enter the code **{user_code}** to authenticate.

    2. Run the **{complete_command}** command in the War Room."""



    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)

    ### END GENERATED CODE ###



    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('AzureRiskyUsers - Beta', 'end', __line__())
  subtype: python3
  type: python
fromversion: 6.0.0
tests:
- No tests (auto formatted)
image: data:image/png;base64,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
detaileddescription: "## Configure Azure Risky Users on Cortex XSOAR\n\n1. Navigate to **Settings** > **Integrations** > **Servers & Services**.\n2. Search for AzureRiskyUsers.\n3. Click **Add instance** to create and configure a new integration instance.\n\n## Authorization\nIn both options below, the [device authorization grant flow](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code) is used.\n\nIn order to connect to Microsoft Risky User using either Cortex XSOAR App or the Self-Deployed App:\n1. Fill in the required parameters.\n2. Run the ***!msgraph-identity-auth-start*** command.\n3. Follow the instructions that appear.\n4. Run the ***!msgraph-identity-auth-complete*** command.\n\n#### Cortex XSOAR App\n\nIn order to use the Cortex XSOAR Azure application, \nuse the application ID (***ec854987-95fa-4c8f-8056-768dd0f409ac***).\n\n#### Self-Deployed App\n\nTo use a self-configured Azure application, you need to add a new Azure App Registration in the Azure Portal, with mobile and desktop flows enabled.\n\n#### Required Permissions\n*Make sure to provide the following permissions for the app to work with Azure Risky Users:*\n - ***IdentityRiskyUser.Read.All*** - https://docs.microsoft.com/en-us/graph/api/riskyuser-list?view=graph-rest-1.0\n - ***IdentityRiskEvent.Read.All*** - https://docs.microsoft.com/en-us/graph/api/riskdetection-get?view=graph-rest-1.0\n \n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/azure-risky-users---beta)"
